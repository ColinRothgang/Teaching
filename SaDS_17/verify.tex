Two sub-fields can be distinguished.

\paragraph{Provers for Dynamic Logics}
These tools are specifically designed to prove correctness of programs.

The programming language may be designed for the tool, or the tool may be designed to work with an existing programming language.
The used programming languages tend to be simpler and more cleanly designed than mainstream languages.
Often they arise as well-behaved fragments of existing languages.

They tend to focus on the programming aspects, allowing for user-facing syntax that looks as similar as possible to typical programs.
They tend to try to hide the logic aspects from the user as much as possible.
Ideally, they only require the user to ascribe loop invariants, class invariants, and pre/postconditions for functions.

Then automated provers can perform the proving in the background.
Usually no proof object is produced.

Examples are Why3\footnote{\url{http://why3.lri.fr/}} \cite{why3} (for a custom imperative language) and KeY\footnote{\url{https://www.key-project.org/}} \cite{key} (for Java-like languages).
    % https://www.lri.fr/~marche/MPRI-2-36-1/


\paragraph{General Purpose Proof Assistants}
These are general-purpose tools for proving formulas.
Many use formal systems that are strong enough to be Turing-complete.

They tend to focus on \emph{pure} programs, i.e., programs where evaluation does not require an environment.
These are usually functional programming languages emphasizing inductive data types and recursive functions.

All proofs are interactive, and the proof assistant supplies as much automation as possible.
The result is a proof term that can be verified independently.

Examples are Coq \cite{coq}, Agda \cite{agda}, PVS \cite{pvs}, and the HOL family \cite{holsemantics}, which includes Isabelle \cite{isabelle}, HOL Light \cite{hollight}, and HOL \cite{hol}.
Major verifications have been done of a C compiler\footnote{\url{http://compcert.inria.fr/}} using Coq\footnote{\url{https://coq.inria.fr/}} and of the L4 micro kernel\footnote{\url{http://ts.data61.csiro.au/projects/TS/l4.verified/}} in Isabelle\footnote{\url{https://isabelle.in.tum.de/}}.

\section{Proof Rules for Dynamic Logic}

We can focus on \emph{partial} correctness because termination can be established separately using termination orders.

Partial correctness requires proving formulas that contain the box operator $\abox{t}{Q}$.
Its proof rules requires a separate case for every possible $t$.

There is quite some variety in choosing the proof rules.
We only give some examples.

Often simplifying assumptions can be made to reduce the difficulty.
Most importantly, it is desirable to restrict side effects as much as possible.
Therefore, we make some restrictions that will be in place throughout this section.

\paragraph{Isolating Side Effects}
One useful restriction is to say that any term that has side effects must occur by itself.

It is straightforward to rewrite programs into equivalent ones that satisfy these conditions.
For example, if $t$ has a side effect, we can rewrite $f(t)$ into the equivalent $\{\aval{x}{A}{t};f(x)\}$.
Exhaustively applying such rewrites eventually yields assignments like $\aval{x}{\Unit}{\aprint{t}}$, which can be rewritten into simply $\aprint{t}$.

That way we can assume that many terms are pure, e.g.,
\begin{compactitem}
 \item definition of a value or mutable variable,
 \item right hand side of an assignment,
 \item conditions in if and while commands,
 \item arguments of a function application, operator application, or print command.
\end{compactitem}

\paragraph{Reasoning Must Be Pure}
A non-optional restriction is that the logical formulas may not have any side-effects at all.
Otherwise, the reasoning itself would affect the thing we want to reason about. That would not make sense.

So in $\abox{P}{F}$, only $P$ but not $F$ may contain assignments, loops, I/O, or control flow commands.
Of course, $P$ may contain booleans again, which may or may not be pure.

Similarly, all annotations such as loop invariants, class invariants, pre/postconditions of functions, and termination orderings must be pure terms.

\subsection{Sequencing}

The rule for $s;t$ first applies $s$, then $t$:

\[\rul{\iscons{}{\Gamma}{}{\abox{s}{\abox{t}{F}}}}{\iscons{}{\Gamma}{}{\abox{s;t}{F}}}
\]

To prove the soundness of this rule, we show that for all states $q$ if all premises hold in $q$, then so does the conclusion.
That is straightforward because the two formulas are equivalent.

\subsection{Branching}

The rule for if commands distinguishes two cases:

\[\rul{\iscons{}{\Gamma}{}{C\impl \abox{t}{F}} \tb \iscons{}{\Gamma}{}{\neg C\impl \abox{t'}{F}}}
      {\iscons{}{\Gamma}{}{\abox{\aifelseI{C}{t}{t'}}{F}}}\]

(Recall that $C$ is assumed to be pure.)

\subsection{Loops}

The rule for while-loops invents a loop invariant $I$:

\[\rul{\iscons{}{\Gamma}{}{I} \tb \iscons{}{\Gamma}{}{(I\wedge C)\impl \abox{t}{I}} \tb \iscons{}{\Gamma}{}{I\wedge \neg C \impl F}}
      {\iscons{}{\Gamma}{}{\abox{\awhileI{C}{I}}{F}}}\]

(Recall that $C$ and $I$ are assumed to be pure.)

%To prove the soundness of this rule, we use induction: we show inductively for all $n$ that $I$ holds are $n$ iterations of the loop.
%The first two premises are exactly the base and step case of the induction. 
%The third premise yields the desired formula $F$ if and whenever the while-loop terminates.

\subsection{Assignments}

Reasoning about assignments is very difficult: we have to keep track of the current value of each mutable variable.
Evaluation delegated that to the environment.
But a proof is static: there is no environment because we are reasoning about what evaluation would do for an arbitrary, unknown initial state.

One simple way is to replace the definition of $x$ in the context.
Effectively, that means we use the context as the environment that holds the current values of the variables.

\[\rul{t \text{ pure} \tb \iscons{}{\Gamma,\amval{x}{A}{t[x/t']},\Gamma'}{}{F}}
      {\iscons{}{\Gamma,\amval{x}{A}{t'},\Gamma'}{}{\abox{x:=t}{F}}}\]
Because $x$ may occur in $t$, we have to substitute its current value for it.

The above rule is sound in many simple situations.
Given the frequency of assignments and the cost of substitution (the entire formula must be traversed), this is not an efficient solution.

Moreover, it easily runs into difficulties when aliasing is allowed, e.g., when using pointers or classes.
If multiple parts of the program can access the same memory location, each assignment must be communicated to all other branches of the derivation.
The above rule does not allow for that because all assignments modify only the context in the current branch.

\subsection{Function Application}

For a function application, we create a local variable for the argument and evaluate the body:

\[\rul{\iscons{}{\Gamma}{}{\abox{\{\aval{x}{A}{a};t\}}{F}}}
      {\iscons{}{\Gamma}{}{\abox{(\alam[A]{x}{t})\,a}{F}}}
\]

\paragraph{Function Specifications}
We do not need a special rule for the application of named functions: those can be replaced with their definition using the usual rules for reasoning about equality.
However, it is useful to have a special rule for when a named function has a specification.

\[\rul{\iscons{}{\Gamma}{}{PfQ} \tb
       \iscons{}{\Gamma}{}{P} \tb
       \iscons{}{\Gamma,\aval{z}{A}{}}{}{}{Q(z)\impl F}}
     {\iscons{}{\Gamma}{}{\abox{z:=f(x_1,\ldots,x_n)}{F}}}\]

Here $PfQ$ abbreviates that $f$ satisfies the specification given by $P$ and $Q$.
That has to be verified once and for all when $f$ is declared.

If $f$ is not recursive and has no separate return-command, the following rule is sound:

\[\rul{\iscons{}{
          \begin{array}{c}\Gamma,
          \afunI[A]{f}{x_1:A_1,\ldots, x_n:A_n}{t},\\
          \aval{x_1}{A_1}{},\ldots,\aval{x_n}{A_n}{},
          \aval{x}{A}{}\end{array}
      }{}{
          P(x_1,\ldots,x_n)\impl \abox{x:=t}{Q(x_1,\ldots,x_n,x)}
      }
    }{\iscons{}{\Gamma,\afunI[A]{f}{x_1:A_1,\ldots, x_n:A_n}{t}}{}{PfQ}}\]

If $f$ is recursive, $PfQ$ has to be assumed in the premise of the rule.

If $f$ uses a return-command, we need a more complex rule, because we cannot use the assignment $x:=t$.

\subsection{Pure Terms}

All other term constructors from Ch.~\ref{sec:sd:typetheory} can simply be ignored because their evaluation has no side effects:

\[\rul{\iscons{}{\Gamma}{}{F}}
      {\iscons{}{\Gamma}{}{\abox{x}{F}}}
\tb\tb
\rul{l \text{ is literal} \tb \iscons{}{\Gamma}{}{F}}
      {\iscons{}{\Gamma}{}{\abox{l}{F}}}
\tb\tb
\rul{\iscons{}{\Gamma}{}{F}}
      {\iscons{}{\Gamma}{}{\abox{\alam[A]{x}{t}}{F}}}
\]

\subsection{Input/Output}

Reasoning about input and output is very difficult and depends on various subtleties.

\paragraph{Unknown Environment}
For example, if the logic does not allow every referring to the special locations $IN$ and $OUT$ of the environment, then formulas can never talk about future reads or past prints.
That makes it easy to give rules that reason about arbitrary states of the environment:

\[\rul{\iscons{}{\Gamma,\aval{x}{\Int}{}}{}{F}}
      {\iscons{}{\Gamma}{}{\abox{x:=\aread}{F}}}
\tb\tb
\rul{t\text{ pure}\tb\iscons{}{\Gamma}{}{F}}
      {\iscons{}{\Gamma}{}{\abox{\aprint{t}}{F}}}
\]

If $F$ cannot talk about upcoming reads, then the result of a read could be anything.
Thus, the only way for $\abox{x:=\aread}{F}$ to hold is if $F$ holds for arbitrary $x$.

Similarly, if $F$ cannot talk about previous prints, the side effect of printing can be ignored.
Thus, if $t$ is pure, $\abox{\aprint{t}}{F}$ holds iff $F$ holds.

\paragraph{Reasoning about Side Effects}
The assumption that the logic cannot talk about the environment is often too restrictive: after all, the communication with the environment is what can be observed by the user.
Therefore, we want our specifications to be able to talk about what will be printed and how the program will respond differently depending on what is read.

That requires additional language features in the logic, which then require more complex proof rules.

\subsection{Local Declarations}

Local value declarations can simply be moved into the context:

\[\rul{t\text{ pure}\tb\iscons{}{\Gamma,\aval{x}{A}{t}}{}{\abox{P}{F}}}
      {\iscons{}{\Gamma}{}{\abox{\{\aval{x}{A}{t}; P\}}{F}}}
\]

Local variable declarations can be moved to the context, too. They will be modified later when assignments are made.

\[\rul{t\text{ pure}\tb\iscons{}{\Gamma,\amval{x}{A}{t}}{}{\abox{P}{F}}}
      {\iscons{}{\Gamma}{}{\abox{\{\amval{x}{A}{t}; P\}}{F}}}
\]

\section{Soundness and Completeness}

\paragraph{Theorems}
Because all formulas are pure, their semantics is just a function from states to $\{\true,\false\}$.

\begin{definition}[Theorem]
A pure term $t:\Bool$ is a \textbf{theorem} if it is $\true$ in every state.
\end{definition}


\paragraph{Soundness}
To formally state the soundness theorem, we need some additional definitions:

\begin{definition}[Soundness]
A set of rules is \textbf{sound} if all provable formulas are theorems.
\end{definition}

In particular, if a set of rules is sound, if every rule's conclusion is a theorem whenever its premises are.

We can now prove the soundness of all rules described above.

\paragraph{Completeness}

It is easy to define completeness:

\begin{definition}[Completeness]
A set of rules is \textbf{complete} if every theorem is provable.
\end{definition}

But it is very difficult to make a dynamic logic complete.

First of all, we have to find a complete calculus for the logic even in the absence of any programs.
That can already be impossible if we allow function types, a built-in type of natural numbers, or inductive data types.
Ultimately, this is due to G\"odel's incompleteness theorem.

Therefore, we usually aim at relative completeness: the rules for programs should be such that they yield a complete calculus if there is/were one for the pure logic.
Dynamic logics are usually relatively complete.
The basic idea of the proof is to show that exhaustively applying the rules (in the presence of sufficient annotations like loop invariants) reduces $\abox{P}{F}$ to a formula without the box operator.

However, our set of rules is not complete: we would have to add some rules or make more restrictions about what programs $P$ we allow.

\section{Verification in Pure Logics}

General purpose proof assistants use pure logics.
There are no assignments, while-loops, I/O, control flow commands, or classes.
Thus, evaluation does not need an environment and can never lead to run-time errors.

Reasoning in these logics can be carried out entirely without the formulas $\abox{P}{F}$.
Any program $P$ is just a term that evaluates to some other term $P'$, and $P==P'$ is a theorem.
Therefore, the usual equality reasoning is sufficient to reason about programs.

Recursive functions are the only source of non-termination.
And non-termination is the only source of abnormal behavior (i.e., there are no run-time errors).

The partial correctness of recursive functions is usually shown using induction arguments.
To prove termination, a variety of families of termination orderings have been developed.
