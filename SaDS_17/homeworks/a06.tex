\documentclass[a4paper]{article}

\usepackage[course={Secure and Dependable Systems},number=6,date=2017-04-27,duedate=2017-05-04,unpublished]{../../myhomeworks}

\newcounter{chapter} % needed for dependencies of mylecturenotes
\usepackage[root=../..]{../../mylecturenotes}
\usepackage{../../macros/algorithm}

\begin{document}

\header

\begin{problem}{Practice: Building an Encryption Scheme}{5}
Implement abstract classes for
\begin{compactitem}
 \item symmetric encryption schemes
 \item block ciphers
\end{compactitem}

Implement concrete classes for
\begin{compactitem}
 \item the block cipher from the example in the lecture
 \item the encryption scheme that takes a block cipher and the IV and uses the CBC mode of operation
\end{compactitem} 
Every instance of the encryption scheme should represent one session, i.e., multiple calls of encryption for the same block should return different results.

Write a unit test that checks the inversion condition: randomly generates some blocks, encrypt and decrypt them, and check for equality.
\end{problem}

\begin{problem}{Practice: Relevance of Modes of Operation}{2}
Use your implementation from the previous problem to encrypt a file.

This should be a real file in an uncompressed format, e.g., a bitmap image.
It should be big enough to consist of many blocks.

Modify your implementation to use the trivial mode of operation (where no IV is used and each block is simply passed to the block cipher).
Encrypt the same file with this mode and compare both results with the original.

Note: This homeworks aims at reproducing the effect from the penguin image example at \url{https://en.wikipedia.org/wiki/Block_cipher_mode_of_operation#Electronic_Codebook_.28ECB.29}.
\end{problem}

\begin{problem}{Theory: Security Analysis}{3}
We define a block cipher that maps a $16$-bit key $k$ to a bijection $E_k:\Z_{16}\to\Z_{16}$ as follows:
\begin{compactitem}
  \item Let $S:\Z_{4}\to\Z_{4}$ be the substitution $x\longmapsto ((x+1)\cdot 3)\modop 5-1$ (which is a bijection).
  \item Let $P:\Z_{16}\to\Z_{16}$ be the permutation that does a cyclic $1$-bit left-shift of the binary representation of its argument.
  \item Let $\mathrm{addKey}_k:\Z_{16}\to\Z_{16}$ be the bijection $x\longmapsto x\oplus k$ (bit-wise xor).
  \item Finally let $E_k$ by $\mathrm{addKey}_{k}\circ P \circ S^4$ where $S^4$ means that $S$ is applied separately to every $4$-bit chunk of its argument.
\end{compactitem}

No we define an encryption scheme using the trivial mode of operation that chooses a key $k$ and then encrypts every $16$-bit block $b$ as $E_k(b)$.

Informally prove the following
\begin{enumerate}
  \item $E$ is comp-ind if $k$ is chosen with a PRG.
  It might help to first show that $\mathrm{addKey}$ applied to each individual block is already comp-ind secure.
  \item $E$ is \emph{not} CPA-ind secure.
  $E$ can be broken deterministically using a chosen-plaintext attack.
  Since the security of $E$ is mainly based on $\mathrm{addKey}$, it might be useful to think about recovering the key using a chosen-plaintext attack. 
\end{enumerate}
\end{problem}

\end{document}
